# -*- coding: utf-8 -*-
"""Linear Programming with different Framework.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HqFt4XxAA39Tnwhax6DKJqFkot2IlMo8

#Sequence:

Problem understanding


Problem Modeling


Programming Language (Pyomo works with many Solver but gurobi works for specific solver)


Solver


Results

#Example:

Max: X+Y

Constraints:

-x+2y <= 8

2x+y <= 14

2x-y <= 10

0 <= x<= 10

0 <= y<= 10

#Tools
There are several frameworks and solvers

#Or-Tools

https://developers.google.com/optimization

Note: Only for linear programming where as pyomo works both linear and non-linear programming

OR-Tools is open source software for combinatorial optimization, which seeks to find the best solution to a problem out of a very large set of possible solutions. Here are some examples of problems that OR-Tools solves:

Vehicle routing: Find optimal routes for vehicle fleets that pick up and deliver packages given constraints (e.g., "this truck can't hold more than 20,000 pounds" or "all deliveries must be made within a two-hour window").


Scheduling: Find the optimal schedule for a complex set of tasks, some of which need to be performed before others, on a fixed set of machines, or other resources.


Bin packing: Pack as many objects of various sizes as possible into a fixed number of bins with maximum capacities.

* Installation
"""

!pip install ortools

from ortools.linear_solver import pywraplp

solver = pywraplp.Solver.CreateSolver('GLOP') #which solver you are gonna use. Glop is the solver by google to solve linear programming... when you need to use Gurobi you just need to put the name 'Gurobi'


#Variables
x=solver.NumVar(0,10,'x') #lower bound , upper bound, string
y=solver.NumVar(0,10,'y')

#Constraints

solver.Add(-x+2*y <= 8)
solver.Add(2*x+y <= 14)
solver.Add(2*x-y <= 10)

#Obejective
solver.Maximize(x+y)


#Results:

results = solver.Solve()

#confirm optimal or not

if results==pywraplp.Solver.OPTIMAL: print('optimal found')

print('x:', x.solution_value())

print('y:', y.solution_value())



"""#Scip

It solves linear, non-linear, integer variables .

#installation of SCIP

for this you need to install condacolab
"""

!pip install -q condacolab
import condacolab
condacolab.install()

!conda install pyscipopt

"""#problem solving

"""

from pyscipopt import Model

model= Model('example')

#creating Variable

x=model.addVar('x')
y=model.addVar('y')

#objective

model.setObjective(x+y, sense='maximize')

#Constraints

model.addCons(-x+2*y <= 8)
model.addCons(2*x+y <= 14)
model.addCons(2*x-y <= 10)


model.optimize()

solution=model.getBestSol()

print('x:', solution[x])
print('y:', solution[y])

"""#Gurobi, CPLEX, GLPK

Paid Version :3
"""

!pip install gurobipy

"""#"""

!pip install gurobi

"""#PYOMO

for linear and non linear
 (that is framworker....at least GLPK need as a solver)

#installation
"""

!pip install pyomo
!apt install glpk-utils
!pip install glpk

!conda install -c conda-forge glpk

"""#Problem Solving with Pyomo"""

import pyomo.environ as pyo

from pyomo.environ import *

from pyomo.opt import SolverFactory

model = pyo.ConcreteModel()

#variables
model.x = pyo.Var (bounds=(0,10))
model.y = pyo.Var (bounds=(0,10))

x=model.x
y=model.y

#Constraints
model.C1 = pyo.Constraint(expr=-x+2*y <= 8 )
model.C2 = pyo.Constraint(expr= 2*x+y <= 14)
model.C3 = pyo.Constraint(expr= 2*x-y <= 10)

#objective

model.obj = pyo.Objective(expr= x+y, sense=maximize)

#Calling a solver
opt=SolverFactory('glpk')
opt.solve(model)

model.pprint() #carefullllllllllllllllll!!

x_value= pyo.value(x)
y_value= pyo.value(y)

print('\n................................................')
print('x:', x_value)
print('y:', y_value)



"""#PuLP"""

!pip install cython

!pip install -q pulp

import pulp as pl

model = pl.LpProblem('Ex', pl.LpMaximize)

#Variable
x = pl.LpVariable('x',0,10)
y = pl.LpVariable('y',0,10)

#Constraints
model += -x+2*y<=8
model += 2*x+y<=14
model += 2*x-y<=10

#objectives
model += x+y

#call the solver
status = model.solve() #empty means cbc solver


#Get optimal Value
x_value = pl.value(x)
y_value = pl.value(y)

print('x=',x_value)
print('y=',y_value)

"""#Problem 2 with PulP"""

import pulp as pl

model = pl.LpProblem('Ex', pl.LpMinimize)

#Variable
x = pl.LpVariable('x',0,3)
y = pl.LpVariable('y',0)

#Constraints
model += x+y<=8
model += 8*x+3*y>=-24
model += -6*x+8*y<=48
model += 3*x+5*y<=15

#objectives
model += -4*x-2*y

#call the solver
status = model.solve() #empty means cbc solver


#Get optimal Value
x_value = pl.value(x)
y_value = pl.value(y)

print('x=',x_value)
print('y=',y_value)

"""#Problem 2 with Pyomo"""

import numpy as np
import time
model = pyo.ConcreteModel()

model.x = pyo.Var(bounds=(-np.inf,3))
model.y = pyo.Var(bounds=(0,np.inf))

x = model.x
y = model.y

model.C1 = pyo.Constraint(expr= x+y<=8)
model.C2 = pyo.Constraint(expr= 8*x+3*y>=-24)
model.C3 = pyo.Constraint(expr= -6*x+8*y<=48)
model.C4 = pyo.Constraint(expr= 3*x+5*y<=15)

model.obj = pyo.Objective(expr= -4*x-2*y, sense=minimize)

tempo_inicial = time.time()
opt = SolverFactory('glpk')
opt.solve(model)
tempo = time.time()-tempo_inicial

x_value = pyo.value(x)
y_value = pyo.value(y)

print('tempo:',tempo)
print('x:',x_value)
print('y:',y_value)

